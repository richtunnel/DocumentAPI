{"version":3,"file":"azure-functions-extensions-base.js","mappings":";;;;;;;;;;;AAAA,sDAAsD;AACtD,kCAAkC;;;;;;;;;;;;;;;;AAElC,gHAA0C;;;;;;;;;;;;ACH1C,sDAAsD;AACtD,kCAAkC;;;AAIlC,MAAa,uBAAuB;IAIhC;;OAEG;IACH;QALQ,sBAAiB,GAAiC,IAAI,GAAG,EAAE,CAAC;QAMhE,uBAAuB;IAC3B,CAAC;IAED;;;OAGG;IACH,MAAM,CAAC,WAAW;QACd,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE;YACnC,uBAAuB,CAAC,QAAQ,GAAG,IAAI,uBAAuB,EAAE,CAAC;SACpE;QACD,OAAO,uBAAuB,CAAC,QAAQ,CAAC;IAC5C,CAAC;IAED;;;;OAIG;IACH,uBAAuB,CAAC,YAAoB,EAAE,OAAwB;QAClE,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YAC1C,MAAM,IAAI,KAAK,CAAC,qBAAqB,YAAY,0BAA0B,CAAC,CAAC;SAChF;QACD,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IACtD,CAAC;IAED;;;;;;;OAOG;IACH,YAAY,CAAC,YAAoB,EAAE,gBAAkC;QACjE,MAAM,eAAe,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACjE,IAAI,CAAC,eAAe,EAAE;YAClB,MAAM,IAAI,KAAK,CACX,qBAAqB,YAAY,iFAAiF,CACrH,CAAC;SACL;QACD,OAAO,eAAe,CAAC,gBAAgB,CAAC,CAAC;IAC7C,CAAC;IAED;;;;;OAKG;IACH,kBAAkB,CAAC,YAAoB;QACnC,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACpD,CAAC;CACJ;AA7DD,0DA6DC;;;;;;;UClED;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://@azure/functions-extensions-base/./src/index.ts","webpack://@azure/functions-extensions-base/./src/resourceFactoryResolver.ts","webpack://@azure/functions-extensions-base/webpack/bootstrap","webpack://@azure/functions-extensions-base/webpack/before-startup","webpack://@azure/functions-extensions-base/webpack/startup","webpack://@azure/functions-extensions-base/webpack/after-startup"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport * from './resourceFactoryResolver';\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { ModelBindingData, ResourceFactory } from '../types';\r\n\r\nexport class ResourceFactoryResolver {\r\n    private static instance: ResourceFactoryResolver;\r\n    private resourceFactories: Map<string, ResourceFactory> = new Map();\r\n\r\n    /**\r\n     * Private constructor to enforce singleton pattern\r\n     */\r\n    private constructor() {\r\n        // Initialize as needed\r\n    }\r\n\r\n    /**\r\n     * Gets the singleton instance of the registry\r\n     * @returns The singleton instance\r\n     */\r\n    static getInstance(): ResourceFactoryResolver {\r\n        if (!ResourceFactoryResolver.instance) {\r\n            ResourceFactoryResolver.instance = new ResourceFactoryResolver();\r\n        }\r\n        return ResourceFactoryResolver.instance;\r\n    }\r\n\r\n    /**\r\n     * Registers a factory for a specific type.\r\n     * @param resourceType The type of the resource factory to check for.\r\n     * @param factory The factory function to create instances of the type.\r\n     */\r\n    registerResourceFactory(resourceType: string, factory: ResourceFactory): void {\r\n        if (this.resourceFactories.has(resourceType)) {\r\n            throw new Error(`Factory for type \"${resourceType}\" is already registered.`);\r\n        }\r\n        this.resourceFactories.set(resourceType, factory);\r\n    }\r\n\r\n    /**\r\n     * Creates a client instance for the specified resource type using the provided model binding data.\r\n     *\r\n     * @param resourceType - The type of the resource for which the client is being created.\r\n     * @param modelBindingData - The data required to bind the model for the resource.\r\n     * @returns An instance of the client for the specified resource type.\r\n     * @throws Error - If no factory is registered for the specified resource type.\r\n     */\r\n    createClient(resourceType: string, modelBindingData: ModelBindingData): unknown {\r\n        const resourceFactory = this.resourceFactories.get(resourceType);\r\n        if (!resourceFactory) {\r\n            throw new Error(\r\n                `Factory for type \"${resourceType}\" is not registered. Register a factory implementation before creating clients.`\r\n            );\r\n        }\r\n        return resourceFactory(modelBindingData);\r\n    }\r\n\r\n    /**\r\n     * Checks if a resource factory of the specified type exists.\r\n     *\r\n     * @param tyresourceTypepe - The type of the resource factory to check for.\r\n     * @returns A boolean indicating whether a resource factory of the specified type exists.\r\n     */\r\n    hasResourceFactory(resourceType: string): boolean {\r\n        return this.resourceFactories.has(resourceType);\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}