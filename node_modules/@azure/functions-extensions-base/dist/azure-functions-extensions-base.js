/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./resourceFactoryResolver */ "./src/resourceFactoryResolver.ts"), exports);


/***/ }),

/***/ "./src/resourceFactoryResolver.ts":
/*!****************************************!*\
  !*** ./src/resourceFactoryResolver.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {


// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceFactoryResolver = void 0;
class ResourceFactoryResolver {
    /**
     * Private constructor to enforce singleton pattern
     */
    constructor() {
        this.resourceFactories = new Map();
        // Initialize as needed
    }
    /**
     * Gets the singleton instance of the registry
     * @returns The singleton instance
     */
    static getInstance() {
        if (!ResourceFactoryResolver.instance) {
            ResourceFactoryResolver.instance = new ResourceFactoryResolver();
        }
        return ResourceFactoryResolver.instance;
    }
    /**
     * Registers a factory for a specific type.
     * @param resourceType The type of the resource factory to check for.
     * @param factory The factory function to create instances of the type.
     */
    registerResourceFactory(resourceType, factory) {
        if (this.resourceFactories.has(resourceType)) {
            throw new Error(`Factory for type "${resourceType}" is already registered.`);
        }
        this.resourceFactories.set(resourceType, factory);
    }
    /**
     * Creates a client instance for the specified resource type using the provided model binding data.
     *
     * @param resourceType - The type of the resource for which the client is being created.
     * @param modelBindingData - The data required to bind the model for the resource.
     * @returns An instance of the client for the specified resource type.
     * @throws Error - If no factory is registered for the specified resource type.
     */
    createClient(resourceType, modelBindingData) {
        const resourceFactory = this.resourceFactories.get(resourceType);
        if (!resourceFactory) {
            throw new Error(`Factory for type "${resourceType}" is not registered. Register a factory implementation before creating clients.`);
        }
        return resourceFactory(modelBindingData);
    }
    /**
     * Checks if a resource factory of the specified type exists.
     *
     * @param tyresourceTypepe - The type of the resource factory to check for.
     * @returns A boolean indicating whether a resource factory of the specified type exists.
     */
    hasResourceFactory(resourceType) {
        return this.resourceFactories.has(resourceType);
    }
}
exports.ResourceFactoryResolver = ResourceFactoryResolver;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=azure-functions-extensions-base.js.map